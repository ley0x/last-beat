{
  "rules": [
    "Follow the clean architecture principles defined in .cursor/rules",
    "Use TypeScript with strict type checking",
    "Prefer functional components with hooks over class components",
    "Use Zod schemas for all data validation and type inference",
    "Follow shadcn/ui patterns and components for consistency",
    "Use TanStack Query for all read operations, Server Actions only for mutations",
    "Implement proper error handling and loading states",
    "Use Jotai for client-side state management",
    "Apply Tailwind CSS utility classes following the design system",
    "Ensure all components are accessible and follow WCAG guidelines"
  ],
  "templates": {
    "react-component": {
      "description": "Create a React component with TypeScript and shadcn/ui patterns",
      "template": "import { cn } from '@/lib/utils'\n\ninterface {{ComponentName}}Props {\n  className?: string\n}\n\nexport function {{ComponentName}}({ className }: {{ComponentName}}Props) {\n  return (\n    <div className={cn('', className)}>\n      {/* Component content */}\n    </div>\n  )\n}"
    },
    "custom-hook": {
      "description": "Create a custom React hook with TypeScript",
      "template": "import { useState, useEffect } from 'react'\n\nexport function {{hookName}}() {\n  // Hook implementation\n  return {\n    // Return values\n  }\n}"
    },
    "zod-schema": {
      "description": "Create a Zod schema with TypeScript inference",
      "template": "import { z } from 'zod'\n\nexport const {{schemaName}}Schema = z.object({\n  // Define schema properties\n})\n\nexport type {{SchemaName}} = z.infer<typeof {{schemaName}}Schema>"
    },
    "api-function": {
      "description": "Create an API function for TanStack Query",
      "template": "export async function {{functionName}}(params: {{ParamsType}}) {\n  const response = await fetch('/api/{{endpoint}}', {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  })\n\n  if (!response.ok) {\n    throw new Error('Failed to {{action}}')\n  }\n\n  return response.json()\n}"
    },
    "server-action": {
      "description": "Create a Next.js Server Action for mutations",
      "template": "'use server'\n\nimport { z } from 'zod'\nimport { revalidatePath } from 'next/cache'\n\nconst {{actionName}}Schema = z.object({\n  // Define input schema\n})\n\nexport async function {{actionName}}(data: z.infer<typeof {{actionName}}Schema>) {\n  try {\n    const validatedData = {{actionName}}Schema.parse(data)\n    \n    // Perform mutation\n    \n    revalidatePath('/{{path}}')\n    return { success: true }\n  } catch (error) {\n    return { error: 'Failed to {{action}}' }\n  }\n}"
    },
    "form-component": {
      "description": "Create a form component with React Hook Form and Zod",
      "template": "'use client'\n\nimport { useForm } from 'react-hook-form'\nimport { zodResolver } from '@hookform/resolvers/zod'\nimport { z } from 'zod'\nimport { Button } from '@/components/ui/button'\nimport { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'\nimport { Input } from '@/components/ui/input'\n\nconst {{formName}}Schema = z.object({\n  // Define form schema\n})\n\ntype {{FormName}}Values = z.infer<typeof {{formName}}Schema>\n\ninterface {{FormName}}Props {\n  onSubmit: (values: {{FormName}}Values) => void\n}\n\nexport function {{FormName}}({ onSubmit }: {{FormName}}Props) {\n  const form = useForm<{{FormName}}Values>({\n    resolver: zodResolver({{formName}}Schema),\n    defaultValues: {\n      // Default values\n    },\n  })\n\n  return (\n    <Form {...form}>\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n        {/* Form fields */}\n        <Button type=\"submit\">Submit</Button>\n      </form>\n    </Form>\n  )\n}"
    },
    "jotai-atom": {
      "description": "Create a Jotai atom for state management",
      "template": "import { atom } from 'jotai'\n\nexport const {{atomName}}Atom = atom<{{AtomType}}>({{initialValue}})\n\n// Derived atoms if needed\nexport const {{derivedAtomName}}Atom = atom(\n  (get) => {\n    const {{atomName}} = get({{atomName}}Atom)\n    // Transform or compute derived value\n    return {{atomName}}\n  }\n)"
    },
    "tanstack-query-hook": {
      "description": "Create a TanStack Query hook",
      "template": "import { useQuery } from '@tanstack/react-query'\nimport { {{apiFunction}} } from '@/lib/api/{{module}}'\n\nexport function {{hookName}}({{params}}) {\n  return useQuery({\n    queryKey: ['{{queryKey}}', {{keyParams}}],\n    queryFn: () => {{apiFunction}}({{params}}),\n    // Additional options\n  })\n}"
    }
  },
  "snippets": {
    "cn": "cn('', $1)",
    "use-query": "const { data, isLoading, error } = useQuery({\n  queryKey: ['$1'],\n  queryFn: () => $2,\n})",
    "use-mutation": "const mutation = useMutation({\n  mutationFn: $1,\n  onSuccess: () => {\n    $2\n  },\n})",
    "zod-object": "z.object({\n  $1\n})",
    "form-field": "<FormField\n  control={form.control}\n  name=\"$1\"\n  render={({ field }) => (\n    <FormItem>\n      <FormLabel>$2</FormLabel>\n      <FormControl>\n        <Input {...field} />\n      </FormControl>\n      <FormMessage />\n    </FormItem>\n  )}\n/>"
  },
  "preferences": {
    "typescript": true,
    "semicolons": false,
    "quotes": "single",
    "trailingComma": "es5",
    "bracketSpacing": true,
    "tabWidth": 2,
    "useTabs": false
  }
}
