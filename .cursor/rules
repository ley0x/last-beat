# Cursor Rules for Last Beat - Next.js Application

## Project Overview

This is a Next.js 15 application using TypeScript, Tailwind CSS, shadcn/ui, and follows clean architecture principles.

## Tech Stack

- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS 4 + shadcn/ui components
- **State Management**: Jotai for client state, TanStack Query for server state
- **Forms**: React Hook Form with Zod validation
- **Animation**: Motion (Framer Motion)

## Architecture Principles

### Clean Architecture Layers

1. **Presentation Layer** (`/src/app`, `/src/components`)
   - React components, pages, layouts
   - UI components from shadcn/ui
   - Client-side state management

2. **Application Layer** (`/src/services`, `/src/hooks`)
   - Business logic
   - Custom hooks
   - Service layer abstractions

3. **Domain Layer** (`/src/lib/types.ts`, `/src/lib/schemas.ts`)
   - Domain models and types
   - Zod schemas for validation
   - Business rules and entities

4. **Infrastructure Layer** (`/src/app/api`, `/src/lib/utils.ts`)
   - External API calls
   - Database access (future: Drizzle)
   - Utility functions

### Directory Structure

```txt
src/
├── app/                   # Next.js App Router pages
│   ├── api/               # API client functions
├── components/            # Reusable UI components
│   ├── ui/                # shadcn/ui components
│   ├── forms/             # Form components
│   ├── features/          # Feature-specific components
│   └── layout/            # Layout components
├── services/              # Service layer abstractions
├── hooks/                 # Custom React hooks
├── lib/                   # Internal library code
│   ├── store.ts           # Jotai atoms and stores
│   ├── schemas.ts         # Zod validation schemas
│   ├── types.ts           # TypeScript type definitions
│   └── utils.ts           # Utility functions
```

## Code Standards

### Data Fetching Rules

- **ONLY use Next.js Server Actions for mutations** (POST, PUT, DELETE, PATCH)
- **Use TanStack Query for all read operations** (GET requests)
- Query functions should be in `/src/features/api/` directory

### TypeScript Rules

- Always use strict TypeScript
- Define interfaces/types in `/src/lib/types.ts`
- Use Zod schemas for runtime validation
- Prefer type-safe patterns with satisfies operator
- Use const assertions where appropriate

### Component Rules

- Use functional components with hooks
- Prefer composition over inheritance
- Extract custom hooks for reusable logic
- Use proper TypeScript props interfaces
- Follow shadcn/ui patterns for consistency
- Never use React.FC for components but prefer functional components with typing arguments directly

### Styling Rules

- Use Tailwind CSS utility classes
- Follow shadcn/ui design system
- Use CSS variables for theming
- Prefer Tailwind over custom CSS
- Use `cn()` utility for conditional classes

### State Management Rules

- **Client State**: Use Jotai atoms for global client state
- **Server State**: Use TanStack Query for server data
- **Form State**: Use React Hook Form with Zod validation
- Keep state as local as possible
- Use proper TypeScript typing for all state

### Form Handling Rules

- Always use React Hook Form with Zod resolvers
- Define schemas in `/src/lib/schemas.ts`
- Use shadcn/ui form components
- Implement proper error handling and validation
- Use Server Actions for form submissions

### File Naming Conventions

- Components: PascalCase (e.g., `UserProfile.tsx`)
- Hooks: camelCase starting with "use" (e.g., `useUserData.ts`)
- Utils: camelCase (e.g., `formatDate.ts`)
- Types: PascalCase (e.g., `User.ts`)
- Schemas: camelCase ending with "Schema" (e.g., `userSchema.ts`)

## Best Practices

### Performance

- Use dynamic imports for code splitting
- Implement proper loading states
- Use React.memo() for expensive components
- Optimize images with Next.js Image component
- Use Suspense boundaries appropriately

### Error Handling

- Implement proper error boundaries
- Use TanStack Query error handling
- Provide meaningful error messages
- Log errors appropriately for debugging

### Accessibility

- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation works
- Follow WCAG guidelines
- Test with screen readers

### Security

- Validate all inputs with Zod schemas
- Sanitize user-generated content
- Use proper authentication (future: Better Auth)
- Implement CSRF protection
- Follow security best practices

## Dependencies Usage

### Core Libraries

- **Next.js**: Use App Router, Server Components, and Server Actions
- **React**: Use hooks, Suspense, and modern patterns
- **TypeScript**: Strict mode with proper typing
- **Tailwind CSS**: Utility-first styling approach

### UI Libraries

- **shadcn/ui**: Primary component library
- **Radix UI**: Headless components (via shadcn/ui)
- **Lucide React**: Icon library
- **Motion**: Animation library (use sparingly)

### State & Data

- **TanStack Query**: Server state management and caching
- **Jotai**: Atomic state management for client state
- **React Hook Form**: Form state and validation
- **Zod**: Schema validation and type inference

### Utilities

- **clsx + tailwind-merge**: Conditional class names via `cn()`
- **class-variance-authority**: Component variant handling
- **next-themes**: Theme management
- **slugify**: URL-friendly string generation

## Future Considerations

- **Authentication**: Integrate Better Auth
- **Database**: Migrate to Drizzle ORM with PostgreSQL
- **Testing**: Add Jest + Testing Library
- **Deployment**: Optimize for Vercel deployment

## Code Quality

- Use ESLint with Next.js config
- Run type checking before commits
- Follow consistent import ordering
- Use absolute imports via TypeScript paths
- Write self-documenting code with clear naming
